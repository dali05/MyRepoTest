package com.lma.apiresponse.api.exception.web;

import com.lma.apiresponse.api.exception.ApiException;
import com.lma.apiresponse.api.exception.ErrorType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.context.request.WebRequest;

import java.util.EnumSet;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class GlobalExceptionHandlerTest {

    private GlobalExceptionHandler handler;

    @Mock
    private WebRequest request;

    @BeforeEach
    void setUp() {
        handler = new GlobalExceptionHandler();
        when(request.getDescription(false)).thenReturn("uri=/api/test");
    }

    // üîπ Sous-classe concr√®te pour tester ApiException abstraite
    static class TestApiException extends ApiException {
        public TestApiException(String code, String message, HttpStatus status, ErrorType type) {
            super(type, status.value(), code, message);
        }
    }

    // ---------------------------------------------------
    // 1Ô∏è‚É£ handleApi(ApiException)
    // ---------------------------------------------------
    @Test
    void testHandleApi_shouldReturnExpectedResponse() {
        ApiException ex = new TestApiException(
                "USER_NOT_FOUND",
                "User not found",
                HttpStatus.NOT_FOUND,
                ErrorType.RESOURCE_NOT_FOUND
        );

        ResponseEntity<ProblemPayload> response = handler.handleApi(ex, request);

        assertNotNull(response);
        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
        assertEquals("application/json", response.getHeaders().getContentType().toString());

        ProblemPayload body = response.getBody();
        assertNotNull(body);
        assertEquals("resource_not_found", body.type());
        assertEquals("Resource not found", body.title());
        assertEquals(404, body.status());
        assertEquals("User not found", body.detail());
        assertTrue(body.instance().contains("/api/test"));
        assertNotNull(body.traceId());
        assertTrue(((Map<?, ?>) body.extensions()).containsKey("code"));
        assertEquals("USER_NOT_FOUND", body.extensions().get("code"));
    }

    // ---------------------------------------------------
    // 2Ô∏è‚É£ handleApi() avec tous les ErrorType pour couvrir typeFor() et titleFor()
    // ---------------------------------------------------
    @Test
    void testHandleApi_shouldHandleAllErrorTypes() {
        for (ErrorType type : EnumSet.allOf(ErrorType.class)) {
            ApiException ex = new TestApiException("CODE", "Message", HttpStatus.BAD_REQUEST, type);
            ResponseEntity<ProblemPayload> response = handler.handleApi(ex, request);

            assertNotNull(response.getBody());
            ProblemPayload body = response.getBody();

            // V√©rifie que chaque type et title correspondent au mapping attendu
            assertNotNull(body.type(), "typeFor() devrait retourner une valeur non nulle pour " + type);
            assertNotNull(body.title(), "titleFor() devrait retourner un titre non nul pour " + type);
        }
    }

    // ---------------------------------------------------
    // 3Ô∏è‚É£ handleValidation(MethodArgumentNotValidException)
    // ---------------------------------------------------
    @Test
    void testHandleValidation_shouldReturnBadRequestWithErrors() {
        FieldError fieldError1 = new FieldError("user", "email", "Invalid email");
        FieldError fieldError2 = new FieldError("user", "name", "Name is required");

        BindingResult bindingResult = mock(BindingResult.class);
        when(bindingResult.getFieldErrors()).thenReturn(List.of(fieldError1, fieldError2));

        MethodArgumentNotValidException ex =
                new MethodArgumentNotValidException(null, bindingResult);

        ResponseEntity<ProblemPayload> response = handler.handleValidation(ex, request);

        assertNotNull(response);
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());

        ProblemPayload body = response.getBody();
        assertNotNull(body);
        assertEquals("validation_error", body.type());
        assertEquals("Validation failed", body.title());
        assertEquals(400, body.status());
        assertEquals("One or more inputs are invalid.", body.detail());

        Map<String, Object> ext = body.extensions();
        assertTrue(ext.containsKey("errors"));

        Map<String, Object> errors = (Map<String, Object>) ext.get("errors");
        assertEquals(2, errors.size());
        assertEquals("Invalid email", errors.get("email"));
        assertEquals("Name is required", errors.get("name"));
    }

    // ---------------------------------------------------
    // 4Ô∏è‚É£ handleUnknown(Exception)
    // ---------------------------------------------------
    @Test
    void testHandleUnknown_shouldReturnInternalServerError() {
        Exception ex = new RuntimeException("Unexpected error");

        ResponseEntity<ProblemPayload> response = handler.handleUnknown(ex, request);

        assertNotNull(response);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());

        ProblemPayload body = response.getBody();
        assertNotNull(body);
        assertEquals("internal_error", body.type());
        assertEquals("Internal Server Error", body.title());
        assertEquals(500, body.status());
        assertEquals("An unexpected error occurred.", body.detail());

        Map<String, Object> ext = body.extensions();
        assertTrue(ext.containsKey("code"));
        assertEquals("INT-500", ext.get("code"));
    }
}
